#=Functions for reading/writing CTL files and running MPB jobs 
=#
using Crystalline
using MPBUtils
using FileIO
using LinearAlgebra
using MPBUtils: _vec2list, _vec2vector3, lattice2mpb, kvecs_from_mpbparams, rewinding_readuntil, SVector
using Crystalline: AbstractFourierLattice
using Brillouin


# Copy-pasted from jl-scripts/read_utils.jl
function try_parse_sgnum(calcname::AbstractString)
    sgstart = findfirst("sg", calcname)[end] + 1         # ... very bad/fragile style:
    sgstop  = findnext(!isdigit, calcname, sgstart) - 1  # should guard for nothing;
    sgnum   = parse(Int, calcname[sgstart:sgstop])       # but can't be asked to...
end
function try_parse_dim(calcname::AbstractString)
    Dstart = findfirst("dim", calcname)[end] + 1
    D = parse(Int, calcname[Dstart])
end



"""
Convert an MPB .sh file that calculates symmetries into one that calculates band structure.
"""
function convertdispersion(filepath_sym; Rs=nothing, newpath=nothing)    
    sg = try_parse_sgnum(filepath_sym)    # int for space group
    # dim = try_parse_dim(filepath_sym)     # int for dimension

    if isnothing(Rs)
        pRs, _, _, _, _, _ = lattice_from_mpbparams(filepath_sym)
        cntr = centering(sgnum, 3) # will be ‘C’ for base-centered
        Rs = conventionalize(pRs, cntr)
    end
    # Gs = reciprocalbasis(Rs)
    kp = irrfbz_path(sg, Rs)
    k_interp = interpolate(kp, 1000)

    # parentdir = dirname(@__DIR__)
    file_contents = readlines(filepath_sym)
    # println(file_contents)
    keys_remove = ["Ws", "ws", "opidxs", "kvecs"]

    if isnothing(newpath)
        calcname, _ = splitext(basename(filepath_sym))
        calcname = calcname * "-disp"
        filepath_disp = joinpath(dirname(filepath_sym), calcname*".sh")
    else
        filepath_disp = newpath*".sh"
    end
    open(filepath_disp, "w") do io
        for line in file_contents
            tokens = split(line, '=')
            if tokens[1] ∉ keys_remove
                write(io, line*"\n")
            end
        end

        write(io, "kvecs", "=")
        kvecs = k_interp
        if kvecs isa AbstractString
            write(io, "\"", kvecs, "\"")
        elseif kvecs isa AbstractVector{<:AbstractVector{<:Real}}
            MPBUtils._vec2list(io, MPBUtils._vec2vector3, kvecs)
        else
            error("incompatible type for kvecs ($(typeof(kvecs)))")
        end
    end
    return Rs, filepath_disp
end

function convertlgs(oldpath, newpath, Rs=nothing)    
    sgnum = try_parse_sgnum(oldpath)    # int for space group
    # dim = try_parse_dim(oldpath)     # int for dimension

    D = 3
    has_tr = true
    brs  = bandreps(sgnum, D, timereversal=has_tr)
    lgs  = Crystalline.matching_littlegroups(brs, Val(D))
    plgs = primitivize.(lgs, #=modw=# false)

    file_contents = readlines(oldpath)
    keys_remove = ["kvecs"]

    open(newpath, "w") do io
        for line in file_contents
            tokens = split(line, '=')
            if tokens[1] ∉ keys_remove
                write(io, line*"\n")
            end
        end

        kvecs = write_lgs_to_mpb!(io, plgs)
        println(io)

        write(io, "kvecs", "=")
        if kvecs isa AbstractString
            write(io, "\"", kvecs, "\"")
        elseif kvecs isa AbstractVector{<:AbstractVector{<:Real}}
            MPBUtils._vec2list(io, MPBUtils._vec2vector3, kvecs)
        else
            error("incompatible type for kvecs ($(typeof(kvecs)))")
        end
    end
    return
end

vec_jl2scm(v) = replace(replace(replace(join(v, ' '), " + "=>"+"), " - "=>"-"), "im"=>"i")

""" 
    prepare_mpbcalc!(...)

Formats a set of parameters that uniquely specify an MPB calculation, given a 
space group number `sgnum`, a Fourier lattice `flat`, a DirectBasis `Rs`, a filling
fraction `filling` for `flat`, interior and exterior (above, below the contour)
permittivities `εin` and `εout`, as well as a list of k-vectors `kvs`, an 
identifying tag `id` (to label the calculation for book-keeping purposes), a 
resolution for the MPB calculation `res`, and a selection of calculation type
`runtype` ("all", "te", or "tm"). The results are written to requested IO `io`.

Our preferred choice is to write these parameters to a bash file, with a name
generated by the `mpb_calcname(...)` method.

The options are expected to be fed to the `fourier-lattice.ctl` file, e.g. through
a bash script of the following kind:
```sh
    IFS=\$'\\n'; # stop command-substitutions from word-splitting at space

    PATH_TO_MPB_EXECUTABLE \\
        (cat \${calcname}.sh)
        ctl/fourier-lattice.ctl 2>&1 | tee logs/\${calcname}.log
        
    unset IFS; # restore usual command-substitution word-splitting practice
```
where `PATH_TO_MPB_EXECUTABLE` is the path to the MPB executable.
Locally, in `mpb-ctl` we have a file `run-fourier-lattice.sh` which performs the 
above, with `calcname` specified as an input parameter (assumed to be a subfolder
`/input/`).
"""
function prepare_mpbcalc_trsb!(
            io::IO,
            sgnum::Integer,
            flat::AbstractFourierLattice{D},
            Rs::AbstractVector{<:AbstractVector},
            filling::Union{Real, Nothing}=0.5, εin::Real=10.0, εout::Real=1.0,
            runtype::String="all",
            g::Real=0,
            gyro_type::String="detfix";
            # kwargs
            id=1,
            res::Integer=32,
            kvs::Union{Nothing, AbstractString, AbstractVector{<:AbstractVector{<:Real}}}=nothing,
            lgs::Union{Nothing, AbstractVector{LittleGroup{D}}}=nothing,
            nbands::Union{Nothing, Integer}=nothing,
            isoval::Union{Nothing, Real}=nothing,
            # TODO: remove below kwarg (here for deprecation of `kvecs` -> `kvs` kwarg)
            kvecs::Union{Nothing, AbstractString, AbstractVector{<:AbstractVector{<:Real}}}=nothing,
            ) where D

    (kvs === nothing && kvecs !== nothing) && (kvs = kvecs) # TODO: remove with `kvecs` kwarg

    # --- prep work to actually call mpb ---
    calcname = mpb_calcname(D, sgnum, id, res, runtype)
    rvecs = _vec2list(_vec2vector3, Rs)
    uc_gvecs, uc_coefs = lattice2mpb(flat)
    if filling !== nothing
        uc_level = filling2isoval(flat, filling)
    elseif isoval !== nothing
        uc_level = isoval
    else
        throw(DomainError((filling, isoval), "Either filling or isoval must be a real number"))
    end
    if filling !== nothing && isoval !== nothing
        throw(DomainError((filling, isoval), "Either filling or isoval must be nothing"))
    end    

    if gyro_type == "simple"
        epsin_offdiag = [1im*g, 0.0, 0.0]
        epsin_diag    = [εin, εin, εin]
    elseif gyro_type == "detfix" # fix determinant, as in Lu et al. Nature Photon. 7, 294 (2013)
        εzz       = εin
        εxx = εyy = sqrt(εzz^2 + g^2)
        epsin_offdiag = [1im*g, 0.0, 0.0]
        epsin_diag    = [εxx, εyy, εzz]
    end

    # prepare and write all runtype, structural, and identifying inputs
    print(io, # run-type ("all", "te", or "tm")
              "run-type", "=",  "\"", runtype,  "\"",  "\n",
              # dimension, space group, and resolution
              "dim",      "=",        D,               "\n",
              "sgnum",    "=",        sgnum,           "\n",
              "res",      "=",        res,             "\n",
              # crystal (basis vectors)
              "rvecs",    "=",        rvecs,           "\n",
              # unitcell/lattice shape
              "uc-gvecs", "=",        uc_gvecs,        "\n",
              "uc-coefs", "=",        uc_coefs,        "\n",
              "uc-level", "=",        uc_level,        "\n",
              # permittivities
              "epsin-diag=(vector3 ",      vec_jl2scm(epsin_diag),               ")\n",
              "epsin-offdiag=(cvector3 ",  vec_jl2scm(epsin_offdiag),            ")\n",
              "epsout-diag=(vector3 ",     vec_jl2scm([εout, εout, εout]), ")\n",
              "epsout-offdiag=(cvector3 ", vec_jl2scm([0.0, 0.0, 0.0]),          ")\n")
    
    if calcname !== nothing && !isempty(calcname)
        println(io, "prefix", "=", "\"", calcname, "\"")
    end
    
    if nbands !== nothing # number of bands to solve for (otherwise default to .ctl choice)
        println(io, "nbands", "=", nbands)
    end

    # prepare and write k-vecs and possibly also little group operations
    if lgs !== nothing
        # if `lgs` is supplied, we interpret it as a request to do symmetry eigenvalue
        # calculations at requested little group k-points
        kvs !== nothing && throw(ArgumentError("One of `kvs` or `lgs` must be nothing"))
        kvs = write_lgs_to_mpb!(io, lgs)
        println(io)
    end

    # write `kvs` (if they are not nothing; we may not always want to give `kvs` explicitly,
    #              e.g. for berry phase calculations)
    write(io, "kvecs", "=")
    if kvs !== nothing 
        if kvs isa AbstractString
            write(io, "\"", kvs, "\"")
        elseif kvs isa AbstractVector{<:AbstractVector{<:Real}}
            _vec2list(io, _vec2vector3, kvs)
        else
            error("incompatible type for `kvs` ($(typeof(kvs)))")
        end
    else
        # easier just to write an empty string than nothing; otherwise we have to bother
        # with figuring out how to remove an empty newline at the end of the file
        write(io, "(list)")
    end

    return nothing
end

"""
    lattice_from_mpbparams(filepath::String)

This will load an input file with path `filepath` that was previously created by
`prepare_mpbcalc(!)` and return the associated lattice as Julia objects.

Output:
```jl
    Rs::DirectBasis,
    flat::ModulatedFourierLattice,
    isoval::Float64,
    epsin::Float64,
    g::Float64
    epsout::Float64
    kvs::Vector{SVector{D, Float64}}
```

Note that `flat` does not retain information about orbit groupings, since we flatten the 
orbits into a single vector in `lattice2mpb`. This doesn't matter as we typically just want
to plot the saved lattice (see `plot_lattice_from_mpbparams` from `compat/pyplot.jl`).
"""
function lattice_from_mpbparams_trsb(io::IO)

    # --- dimension ---
    readuntil(io, "dim=")
    D = parse(Int64, readline(io))

    # --- basis vectors ---
    rewinding_readuntil(io, "rvecs=")
    vecs = Tuple(Vector{Float64}(undef, D) for _ in 1:D)
    for R in vecs
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        R .= parse.(Ref(Float64), coords)
    end
    Rs = DirectBasis{D}(vecs...)

    # --- ("flattened") orbits ---
    rewinding_readuntil(io, "uc-gvecs=")
    gvecs = Vector{SVector{D, Int64}}() 
    while true
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        next_gvec = parse.(Ref(Int64), coords)
        push!(gvecs, next_gvec)
        (read(io, Char) == ')') && break # look for a closing (double) parenthesis to match the assumed opening "(list "
    end

    # --- ("flattened") orbit coefficients --- 
    rewinding_readuntil(io, "uc-coefs=")
    readuntil(io, "(list ")
    gcoefs = Vector{ComplexF64}(undef, length(gvecs)) 
    for n in eachindex(gcoefs)
        gcoefs[n] = parse(ComplexF64, readuntil(io, x -> isspace(x) || x==')'))
    end

    # --- ("flattened") Fourier Lattice ---
    # note that we've lost info about orbit groupings (since we flatten on exporting 
    # to mpb in lattice2mpb(...)) but it doesn't matter much, as we only ever need
    # to reload these to see the lattice itself.
    flat = ModulatedFourierLattice{D}([gvecs], [gcoefs])

    # --- iso-level ---
    rewinding_readuntil(io, "uc-level=")
    isoval = parse(Float64, readline(io))

    # --- epsilon values ---
    rewinding_readuntil(io, "epsin-diag=(vector3 ")
    epsin_diag = tryparse(Float64, split(readline(io), (' ', ')'))[3])
    rewinding_readuntil(io, "epsin-offdiag=(cvector3 ")
    epsin_offdiag = tryparse(ComplexF64, split(readline(io))[1])
    g = imag(epsin_offdiag)
    rewinding_readuntil(io, "epsout-diag=(vector3 ")
    epsout = tryparse(Float64, split(readline(io), (' ', ')'))[1])

    # --- k-vectors ---
    kvs = kvecs_from_mpbparams(io, Val(D))

    return Rs, flat, isoval, epsin_diag, g, epsout, kvs
end
lattice_from_mpbparams_trsb(filepath::String) = open(filepath) do io; lattice_from_mpbparams_trsb(io); end


"""
Calculate symmetry eigenvalues and topological index using MPB. Includes workarounds for random Supercloud errors.

# Arguments
- `symcalcname::String`: The path name to use, excluding the extension and top directory (i.e. "input/")
- `writectlfun!::Function`: Function that takes `io` and `kwargs` as an input, and writes the .ctl file
- `topofun::Function`: Function that returns the topological index

# Examples
```symcalcname = joinpath(sub_dir, "1-sym")
has_tr=false
band_topo = run_mpb_sym(symcalcname,
        (io;kwargs...)->prepare_mpbcalc_trsb!(io, sgnum, flat_temp, pRs, ff, epsin, epsout, runtype, 
            g, gyro_type;
            res=res, nbands=nbands, kwargs...),
        ()->checktopoindex(sgnum, symcalcname, topoindex=topoindex, dir=out_dir),
        has_tr;
        indir=in_dir,
        tmpdir=tmpdir
    )```
"""
function run_mpb_sym(symcalcname::String, write_ctl_fun!::Function, topofun::Function, has_tr::Bool; 
        indir::String="input", tmpdir=false, )

    time = @elapsed begin

    hasrun = false
    band_topo = nothing
    ntries = 0
    # Supercloud randomly errors out, so we try running until we get a result
    while !hasrun
        try
            # Prepare MPB file for symmetry calculation
            D = 3
            pathlgs = joinpath(indir, symcalcname*".sh")
            brs  = bandreps(sgnum, D, timereversal=has_tr)
            lgs  = Crystalline.matching_littlegroups(brs, Val(D))
            plgs = primitivize.(lgs, #=modw=# false)
            open(pathlgs, "w") do io
                # prepare_mpbcalc_trsb!(io, sgnum, flat_temp, pRs, ff, epsin, epsout, runtype,
                #                     g, gyro_type;
                #                     res=res, lgs=plgs, id=id, nbands=nbands)
                write_ctl_fun!(io; lgs=plgs)
            end

            # Run MPB
            if tmpdir
                run(`./run-fourier-lattice-sc.sh $symcalcname`)
            else
                run(`./run-fourier-lattice.sh $symcalcname`)
            end

            # Calculate topological index
            band_topo = topofun()
            println(band_topo)
            hasrun = true
        catch e
            if e == ErrorException("at row 0, column 0 : ArgumentError(\"number of rows in dims must be > 0, got 0\")")
                println(e)
                @error "Something went wrong" exception=(e, catch_backtrace())
            else
                throw(e)
            end
            ntries += 1
            if ntries >= 5
                @error ("Tried 5 times. Ending run.")
                throw(e)
            end
        end
    end

    end
    println("Time for symmetry calculation: $time")
    return band_topo
end


"""
Calculate full dispersion using MPB and objective. Includes workarounds for random Supercloud errors.

# Arguments
- `shcalcname::String`: The path name to use, excluding the extension
- `writectlfun!::Function`: Function that takes io as an input, and writes the .ctl file
- `objectivefun::Function`: Function that calculates the objective
"""
function run_mpb(shcalcname::String, writectlfun!::Function, objectivefun::Function; 
    hasinv::Bool=false, dir="input", tmpdir=false)

    # Run MPB
    # Supercloud randomly errors out, so we try running until we get a result
    objectiveval = nothing
    ntries = 1
    while isnothing(objectiveval)
        try
            time = @elapsed begin
                pathtemp = joinpath(dir, shcalcname*".sh")
                open(pathtemp, "w") do io
                    writectlfun!(io)
                end

                if hasinv
                    if tmpdir
                        run(`./run-mpbi-fourier-lattice-sc.sh $shcalcname`)
                    else
                        run(`./run-mpbi-fourier-lattice.sh $shcalcname`)
                    end
                else
                    # time = @elapsed run(`./run-mpb-fourier-lattice-sc.sh $shcalcname`)
                    if tmpdir
                        run(`./run-mpb-fourier-lattice-sc.sh $shcalcname`)
                    else
                        run(`./run-mpb-fourier-lattice.sh $shcalcname`)
                    end
                end

                objectiveval = objectivefun()
                println("Objective: $objectiveval")
            end

            println("Time for dispersion calculation: $time")
        catch e
            # These are list of errors usually associated with SuperCloud acting up.
            # Other errors we will throw.
            if e == ErrorException("at row 0, column 0 : ArgumentError(\"number of rows in dims must be > 0, got 0\")")
                println(e)
                @error "Something went wrong" exception=(e, catch_backtrace())
            else
                throw(e)
            end
            ntries += 1
            if ntries > 5
                @error ("Tried 5 times. Ending run.")
                throw(e)
            end
        end
    end
    return objectiveval
end


